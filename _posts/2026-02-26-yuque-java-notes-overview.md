---
title: "语雀《学习文档》内容整理：Java 后端知识地图（站内独立版）"
date: "2026-02-26"
tags:
  - Java
  - 后端
  - 学习笔记
  - 分布式
categories:
  - 工具
excerpt: "将原语雀学习清单整理为站内独立文档，按并发、JVM、网络、缓存、消息队列、限流和 GC 七大模块给出核心概念、实现要点与排查清单，避免依赖外链跳转。"
cover: "/assets/images/social-card.svg"
---

# 语雀《学习文档》内容整理：Java 后端知识地图（站内独立版）

> 说明：本文已将原“目录 + 外链”形式改为站内可直接阅读的独立文档。

## 一、全景知识地图

Java 后端知识可按 3 层能力来组织：

1. **基础运行时层**：并发编程、JVM、IO、TCP/IP。
2. **数据与性能层**：Redis、缓存、分布式缓存。
3. **分布式治理层**：消息中间件、限流、GC 与稳定性优化。

建议学习策略：先构建“运行时 + 网络”底座，再进入“缓存 + 消息”中间件，最后补齐“限流 + GC”稳定性治理。

---

## 二、并发编程（Concurrency）

### 1. 核心目标
- 让多线程在**正确性**（不出错）和**性能**（吞吐/延迟）之间取得平衡。

### 2. 必会概念
- 线程与进程、用户态与内核态切换。
- 可见性、原子性、有序性（JMM 三大问题）。
- `synchronized`、`volatile`、`Lock`、`CAS`。
- 线程池参数：核心线程数、队列、拒绝策略。

### 3. 高频实践
- IO 密集型场景：线程数可大于 CPU 核数。
- CPU 密集型场景：线程数通常接近 CPU 核数。
- 避免在业务代码里滥用 `new Thread()`，统一收敛到线程池。

### 4. 常见故障定位
- 吞吐下降：看线程池队列堆积与上下文切换。
- 响应变慢：排查锁竞争、长临界区与阻塞调用。
- 偶发错误：优先怀疑共享变量发布与并发容器使用方式。

---

## 三、JVM 整理（Java Runtime）

### 1. 执行路径
`.java` 源码 → 编译成 `.class` → 类加载（加载/链接/初始化）→ 字节码执行。

### 2. 运行时内存区域
- 堆（对象分配主区域）
- 虚拟机栈（方法调用）
- 方法区/元空间（类元数据）
- 程序计数器、本地方法栈

### 3. 类加载机制
- 双亲委派模型：避免核心类被篡改、避免重复加载。
- 重点掌握：何时触发类初始化、何时只加载不初始化。

### 4. 排查主线
- `OOM`：先看堆、再看元空间、最后看直接内存。
- `Full GC` 频繁：看对象晋升、内存分配速率与大对象分配。

---

## 四、IO 与 TCP/IP 基础

### 1. IO 模型
- **BIO**：阻塞式，编码简单，连接数大时扩展性弱。
- **NIO**：多路复用，适合高并发网络场景。
- **AIO**：异步回调，模型复杂但理论并发能力更高。

### 2. TCP/IP 关键点
- 三次握手、四次挥手。
- 滑动窗口、重传机制、拥塞控制。
- `TIME_WAIT` 过多与连接复用。

### 3. 后端实践关注
- 长连接与短连接的取舍。
- 粘包拆包与应用层协议设计。
- 超时设置（连接超时 / 读超时 / 写超时）分层治理。

---

## 五、Redis、缓存与分布式缓存

### 1. Redis 认知
- 数据结构：String、Hash、List、Set、ZSet。
- 常见底层结构：动态字符串、哈希表、跳表等。
- 场景：缓存、分布式锁、计数器、排行榜。

### 2. 缓存三大问题
- 缓存穿透：查不到的数据反复打 DB。
- 缓存击穿：热点 key 失效瞬间冲垮后端。
- 缓存雪崩：大量 key 同时过期导致服务雪崩。

### 3. 常用治理手段
- 空值缓存 + BloomFilter。
- 热点 key 永不过期或逻辑过期。
- 过期时间打散 + 多级缓存（本地 + Redis）。

### 4. 分布式缓存设计要点
- 一致性：先更新库还是先删缓存要有统一策略。
- 可用性：主从、哨兵、集群模式按业务体量选择。
- 可观测性：命中率、慢查询、内存碎片率、连接数必须可监控。

---

## 六、消息中间件（RocketMQ / Pulsar）

### 1. 为什么需要 MQ
- 解耦：生产者与消费者职责分离。
- 削峰：瞬时流量用队列缓冲。
- 异步：把非核心链路改为异步处理。

### 2. 关键语义
- 至少一次、至多一次、尽力一次（语义与成本权衡）。
- 顺序消息、延迟消息、事务消息。
- 幂等消费：用业务主键或去重表防重。

### 3. RocketMQ 与 Pulsar（选型视角）
- RocketMQ：工程化成熟，国内生态与实践丰富。
- Pulsar：存算分离架构突出，多租户能力更强。
- 选型优先看：团队经验、运维复杂度、生态整合成本。

### 4. 常见问题
- 消息堆积：消费者能力不足或下游阻塞。
- 重复消费：业务层必须实现幂等。
- 消息丢失：生产、存储、消费确认链路逐层兜底。

---

## 七、限流算法与稳定性治理

### 1. 常见限流算法
- 固定窗口计数器：实现简单，但临界突刺明显。
- 滑动窗口：统计更平滑，复杂度略高。
- 令牌桶：允许突发，整体速率可控。
- 漏桶：输出速率稳定，适合下游保护。

### 2. 落地策略
- 网关层做全局限流（按 IP、接口、租户）。
- 服务层做资源限流（线程池、连接池、QPS）。
- 降级与熔断联动，避免“限流成功但服务仍雪崩”。

### 3. 观测指标
- 限流触发率、请求拒绝率、95/99 线延迟、错误率。

---

## 八、GC 算法与内存调优

### 1. 垃圾回收核心思想
- 判断对象是否存活（可达性分析）。
- 回收策略：标记-清除、标记-整理、复制算法。

### 2. 分代回收思路
- 新生代：对象朝生夕灭，回收频繁。
- 老年代：存活对象多，回收成本高。

### 3. 调优方法论
- 先看日志与监控，再改参数。
- 关注吞吐优先还是停顿优先。
- 避免“凭感觉调参”，每次变更都要可回滚、可对比。

---

## 九、4 周复习路线（可直接执行）

### 第 1 周：并发 + JVM
- 输出：线程池参数模板 + 常见 OOM 排查清单。

### 第 2 周：IO + TCP/IP + 缓存基础
- 输出：服务超时治理基线 + 缓存问题排查手册。

### 第 3 周：Redis + 分布式缓存 + MQ
- 输出：热点 key 保护方案 + 消费幂等模板。

### 第 4 周：限流 + GC + 全链路复盘
- 输出：接口限流策略表 + GC 监控看板指标清单。

---

## 十、作为站内文档的后续维护建议

- 每个主题继续拆分为三部分：**概念卡片 / 面试题 / 最小可运行代码**。
- 每次新增知识点时补齐：**适用场景、边界条件、故障信号、排查命令**。
- 在文章末尾维护“版本记录”，确保知识地图可追踪迭代。
